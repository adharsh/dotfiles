#!/usr/bin/env python3
import argparse
import csv
from typing import List, Tuple
import sys
import tempfile
import shutil
import os

def get_column_widths(file_path: str) -> Tuple[List[int], List[List[str]]]:
    """
    Read the CSV file and determine the maximum width of each column.
    Returns the list of column widths and the data.
    """
    max_widths = []
    all_rows = []
    
    try:
        with open(file_path, 'r', newline='') as csvfile:
            reader = csv.reader(csvfile)
            for row_num, row in enumerate(reader):
                all_rows.append(row)
                # Initialize max_widths list if this is the first row
                if not max_widths:
                    max_widths = [0] * len(row)
                
                # Update maximum widths for each column
                for i, field in enumerate(row):
                    max_widths[i] = max(max_widths[i], len(field))
    
    except FileNotFoundError:
        print(f"Error: File '{file_path}' not found.", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error reading CSV file: {str(e)}", file=sys.stderr)
        sys.exit(1)
        
    return max_widths, all_rows

def format_csv(input_file: str, output_file: str = "", preview: bool = False) -> None:
    """
    Format the CSV file with proper alignment.
    If preview is True, print to stdout.
    If output_file is None, overwrite the input file.
    """
    max_widths, all_rows = get_column_widths(input_file)
    
    # Prepare formatted content
    formatted_rows = []
    for row in all_rows:
        formatted_fields = []
        for i, field in enumerate(row):
            # For all columns except the last one, pad with spaces after the comma
            if i < len(row) - 1:
                padding = max_widths[i] - len(field)
                formatted_fields.append(f"{field}," + " " * padding)
            else:
                # Last column doesn't need padding
                formatted_fields.append(field)
        formatted_rows.append("".join(formatted_fields))
    
    formatted_content = "\n".join(formatted_rows)
    
    if preview:
        print(formatted_content)
        return
        
    if output_file is None:
        # Create a temporary file
        fd, temp_path = tempfile.mkstemp(text=True)
        try:
            with os.fdopen(fd, 'w') as temp_file:
                temp_file.write(formatted_content)
            # Replace the original file with the temporary file
            shutil.move(temp_path, input_file)
            print(f"File '{input_file}' has been formatted in place.")
        except Exception as e:
            print(f"Error writing to file: {str(e)}", file=sys.stderr)
            # Clean up the temporary file if it still exists
            if os.path.exists(temp_path):
                os.unlink(temp_path)
            sys.exit(1)
    else:
        try:
            with open(output_file, 'w') as f:
                f.write(formatted_content)
            print(f"Formatted CSV has been written to '{output_file}'")
        except Exception as e:
            print(f"Error writing to output file: {str(e)}", file=sys.stderr)
            sys.exit(1)

def main():
    parser = argparse.ArgumentParser(
        description="Format CSV files with dynamic column alignment"
    )
    parser.add_argument(
        "input_file",
        help="Input CSV file to format"
    )
    parser.add_argument(
        "-o", "--output",
        help="Output file (optional, defaults to overwriting input file)",
        default=None
    )
    parser.add_argument(
        "-p", "--preview",
        help="Preview the formatted output without writing to file",
        action="store_true"
    )
    
    args = parser.parse_args()
    format_csv(args.input_file, args.output, args.preview)

if __name__ == "__main__":
    main()