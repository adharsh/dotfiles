#!/home/adharsh/miniforge3/envs/sgpt/bin/python3.12
"""
ProjectSnapshot: A tool to generate a snapshot of your project.

This script creates a comprehensive snapshot of a project directory,
including its structure and file contents, while respecting gitignore patterns.

Example usage:
    Basic usage:
    $ projectsnap

    Assume yes for all prompts:
    $ projectsnap -y

    Specify custom directory and output file:
    $ projectsnap -d /path/to/project -o output.txt

    Pipe output and count characters:
    $ projectsnap -y | wc -c

    Pipe output of only directory structur and count characters:
    $ echo -e "y\nn" | projectsnap | wc -c

For more information, use the --help option:
    $ python projectsnap.py --help
"""

import fnmatch
import argparse
import sys
from pathlib import Path
from typing import List, Set, TextIO

class ProjectSnapshotConfig:
    def __init__(
        self,
        root_dir: Path,
        output_file: TextIO,
        ignore_files: Set[str],
        assume_yes: bool,
    ):
        self.root_dir = root_dir
        self.output_file = output_file
        self.ignore_files = ignore_files
        self.assume_yes = assume_yes

class ProjectSnapshot:
    def __init__(self, config: ProjectSnapshotConfig):
        self.config = config
        self.gitignore_patterns = self._load_gitignore()

    def _load_gitignore(self) -> List[str]:
        gitignore_path = self.config.root_dir / ".gitignore"
        if gitignore_path.exists():
            with gitignore_path.open("r") as f:
                return [
                    line.strip()
                    for line in f
                    if line.strip() and not line.startswith("#")
                ]
        return []

    def is_ignored(self, file_path: Path) -> bool:
        relative_path = file_path.relative_to(self.config.root_dir)

        if any(part in self.config.ignore_files for part in relative_path.parts):
            return True

        return any(
            fnmatch.fnmatch(str(relative_path), pattern)
            for pattern in self.gitignore_patterns
        )

    def generate_directory_tree(self, dir_path: Path, prefix: str = "") -> str:
        tree = ""
        entries = sorted(dir_path.iterdir(), key=lambda e: e.name)

        for i, entry in enumerate(entries):
            if self.is_ignored(entry):
                continue

            is_last = i == len(entries) - 1
            marker = "└── " if is_last else "├── "
            new_prefix = prefix + ("    " if is_last else "│   ")

            tree += f"{prefix}{marker}{entry.name}\n"

            if entry.is_dir():
                tree += self.generate_directory_tree(entry, new_prefix)

        return tree

    def compile_project(self):
        self.config.output_file.write("Project Code Transcript\n\n")

        if prompt_user("Include directory structure? (y/n): ", self.config.assume_yes):
            self.config.output_file.write("Directory Structure:\n\n")
            self.config.output_file.write(
                self.generate_directory_tree(self.config.root_dir)
            )
            self.config.output_file.write("\n")

        if prompt_user("Include file contents? (y/n): ", self.config.assume_yes):
            self.config.output_file.write("File Contents:\n")
            self._write_file_contents(self.config.root_dir)

    def _write_file_contents(self, dir_path: Path):
        for file_path in dir_path.rglob("*"):
            if self.is_ignored(file_path):
                continue

            if file_path.is_file():
                try:
                    with file_path.open("r", encoding="utf-8") as f:
                        content = f.read()

                    self.config.output_file.write(
                        f"\n\n--- File: {file_path.relative_to(self.config.root_dir)} ---\n\n"
                    )
                    self.config.output_file.write(content)
                except Exception as e:
                    print(f"Error reading file {file_path}: {str(e)}", file=sys.stderr)


def prompt_user(question: str, assume_yes: bool) -> bool:
    if assume_yes:
        return True
    
    while True:
        response = input(question).lower()
        if response in {"y", "yes"}:
            return True
        elif response in {"n", "no"}:
            return False
        else:
            print("Please answer with 'y' or 'n'.")

def parse_arguments():
    parser = argparse.ArgumentParser(
        description="Generate a snapshot of your project.",
        epilog="For more examples and usage, refer to the script's docstring."
    )
    parser.add_argument(
        "-d",
        "--directory",
        type=Path,
        default=Path("./"),
        help="Root directory of the project",
    )
    parser.add_argument(
        "-o",
        "--output",
        type=argparse.FileType("w"),
        default=sys.stdout,
        help="Output file path (default: stdout)",
    )
    parser.add_argument(
        "-i",
        "--ignore",
        nargs="+",
        default=["node_modules", "package.json", "package-lock.json", ".git"],
        help="Files and directories to ignore",
    )
    parser.add_argument(
        "-y",
        "--yes",
        action="store_true",
        help="Assume yes for all prompts",
    )
    return parser.parse_args()

def main():
    args = parse_arguments()

    config = ProjectSnapshotConfig(
        root_dir=args.directory,
        output_file=args.output,
        ignore_files=set(args.ignore),
        assume_yes=args.yes,
    )

    snapshot = ProjectSnapshot(config)

    try:
        snapshot.compile_project()
        if args.output != sys.stdout:
            print(f"Transcript compiled to {args.output.name}", file=sys.stderr)
    except Exception as e:
        print(f"An error occurred: {str(e)}", file=sys.stderr)
    finally:
        if args.output != sys.stdout:
            args.output.close()

if __name__ == "__main__":
    main()