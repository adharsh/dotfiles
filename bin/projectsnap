#!/home/adharsh/miniforge3/envs/sgpt/bin/python3.12
"""
ProjectSnapshot: A tool to generate a snapshot of your project.

This script creates a comprehensive snapshot of a project directory,
including its structure and file contents, while respecting gitignore patterns.

Example usage:
    Basic usage:
    $ projectsnap

    Include only Python files, ignore test files, and output to a file:
    $ projectsnap --include "*.py" --ignore "*_test.py" -o output.txt

    Specify custom directory, include patterns, and assume yes for all prompts:
    $ projectsnap -d /path/to/project --include "*.py" "*.txt" -y

    Include all files except those in 'build' directory:
    $ projectsnap --include "*" --ignore "build/*"

    Pipe output and count characters:
    $ projectsnap --include "*.md" | wc -c

For more information, use the --help option:
    $ python projectsnap.py --help
"""

import re
import argparse
import sys
from pathlib import Path
from typing import List, TextIO


class ProjectSnapshotConfig:
    def __init__(
        self,
        root_dir: Path,
        include_patterns: List[str],
        ignore_patterns: List[str],
        output_file: TextIO,
        assume_yes: bool,
    ):
        self.root_dir = root_dir
        self.include_patterns = include_patterns
        self.ignore_patterns = ignore_patterns
        self.output_file = output_file
        self.assume_yes = assume_yes


class ProjectSnapshot:
    def __init__(self, config: ProjectSnapshotConfig):
        self.config = config
        self.gitignore_patterns = self._load_gitignore()

    def _load_gitignore(self) -> List[str]:
        gitignore_path = self.config.root_dir / ".gitignore"
        if gitignore_path.exists():
            with gitignore_path.open("r") as f:
                return [
                    line.strip()
                    for line in f
                    if line.strip() and not line.startswith("#")
                ]
        return []

    def is_included(self, file_path: Path) -> bool:
        relative_path = file_path.relative_to(self.config.root_dir)
        path_str = str(relative_path).replace("\\", "/")  # Normalize path separators

        # Check if the file matches any ignore patterns
        for pattern in self.config.ignore_patterns + self.gitignore_patterns:
            if self._matches_pattern(path_str, pattern, file_path.is_dir()):
                return False

        # Check if the file matches any include patterns
        if self.config.include_patterns and not any(
            self._matches_pattern(path_str, pattern, file_path.is_dir())
            for pattern in self.config.include_patterns
        ):
            return False

        return True

    def _matches_pattern(self, path: str, pattern: str, is_dir: bool) -> bool:
        # Remove leading slash if present
        if pattern.startswith("/"):
            pattern = pattern[1:]

        # Handle directory-specific patterns
        if pattern.endswith("/"):
            if not is_dir:
                return False
            pattern = pattern[:-1]

        # Convert gitignore pattern to regex
        regex = (
            re.escape(pattern)
            .replace(r"\*\*", ".*")
            .replace(r"\*", "[^/]*")
            .replace(r"\?", ".")
        )
        regex = f"^{regex}$|^{regex}/"

        return re.match(regex, path) is not None

    def generate_directory_tree(self, dir_path: Path, prefix: str = "") -> str:
        tree = ""
        entries = sorted(dir_path.iterdir(), key=lambda e: e.name)

        for i, entry in enumerate(entries):
            is_last = i == len(entries) - 1
            marker = "└── " if is_last else "├── "
            new_prefix = prefix + ("    " if is_last else "│   ")

            if entry.is_dir():
                subtree = self.generate_directory_tree(entry, new_prefix)
                if subtree:  # If subtree is not empty, include this directory
                    tree += f"{prefix}{marker}{entry.name}\n"
                    tree += subtree
            elif self.is_included(entry):
                tree += f"{prefix}{marker}{entry.name}\n"

        return tree

    def compile_project(self):
        self.config.output_file.write("Project Code Transcript\n\n")

        if prompt_user("Include directory structure? (y/n): ", self.config.assume_yes):
            self.config.output_file.write("Directory Structure:\n\n")
            self.config.output_file.write(
                self.generate_directory_tree(self.config.root_dir)
            )
            self.config.output_file.write("\n")

        if prompt_user("Include file contents? (y/n): ", self.config.assume_yes):
            self.config.output_file.write("File Contents:\n")
            self._write_file_contents(self.config.root_dir)

    def _write_file_contents(self, dir_path: Path):
        for file_path in dir_path.rglob("*"):
            if not self.is_included(file_path):
                continue

            if file_path.is_file():
                try:
                    with file_path.open("r", encoding="utf-8") as f:
                        content = f.read()

                    self.config.output_file.write(
                        f"\n\n--- BEGIN FILE: {file_path.relative_to(self.config.root_dir)} ---\n\n"
                    )
                    self.config.output_file.write(content)
                    self.config.output_file.write(
                        f"\n\n--- END FILE: {file_path.relative_to(self.config.root_dir)} ---\n\n"
                    )
                except Exception as e:
                    print(f"Error reading file {file_path}: {str(e)}", file=sys.stderr)


def prompt_user(question: str, assume_yes: bool) -> bool:
    if assume_yes:
        return True

    while True:
        response = input(question).lower()
        if response in {"y", "yes"}:
            return True
        elif response in {"n", "no"}:
            return False
        else:
            print("Please answer with 'y' or 'n'.")


def parse_arguments():
    parser = argparse.ArgumentParser(
        description="Generate a snapshot of your project.",
        epilog="For more information and usage examples, refer to the script's docstring.",
    )
    parser.add_argument(
        "-d",
        "--directory",
        type=Path,
        default=Path("./"),
        help="Root directory of the project",
    )
    parser.add_argument(
        "-i",
        "--include",
        nargs="+",
        default=[],
        help="Gitignore-style patterns to include (overrides ignore patterns)",
    )
    parser.add_argument(
        "--ignore",
        nargs="+",
        default=["node_modules", "package.json", "package-lock.json", ".git"],
        help="Additional gitignore-style patterns to ignore",
    )
    parser.add_argument(
        "-o",
        "--output",
        type=argparse.FileType("w"),
        default=sys.stdout,
        help="Output file path (default: stdout)",
    )
    parser.add_argument(
        "-y",
        "--yes",
        action="store_true",
        help="Assume yes for all prompts",
    )
    return parser.parse_args()


def main():
    args = parse_arguments()

    config = ProjectSnapshotConfig(
        root_dir=args.directory,
        include_patterns=args.include,
        ignore_patterns=args.ignore,
        output_file=args.output,
        assume_yes=args.yes,
    )

    snapshot = ProjectSnapshot(config)
    try:
        snapshot.compile_project()
        if args.output != sys.stdout:
            print(f"Transcript compiled to {args.output.name}", file=sys.stderr)
    except Exception as e:
        print(f"An error occurred: {str(e)}", file=sys.stderr)
    finally:
        if args.output != sys.stdout:
            args.output.close()


if __name__ == "__main__":
    main()
