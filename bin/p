#!/home/adharsh/miniforge3/envs/basic/bin/python

import argparse
from collections import OrderedDict
import ast
import numpy as np
import pandas as pd
from datetime import datetime, timedelta
from pathlib import Path

def parse_args():
    parser = argparse.ArgumentParser(
        description='Analyze curriculum progress and estimate completion deadlines',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    parser.add_argument(
        'csv_file',
        type=Path,
        help='Path to CSV file containing curriculum progress'
    )
    parser.add_argument(
        '--focus-hours-day', '-d',
        type=float,
        default=7.0,
        help='Number of focus hours per day'
    )
    parser.add_argument(
        '--focus-hours-week', '-w',
        type=float,
        default=49.0,
        help='Number of focus hours per week'
    )
    args = parser.parse_args()
    
    if not args.csv_file.exists():
        parser.error(f"CSV file not found: {args.csv_file}")
        
    return args

def safe_eval(expr):
    """Safely evaluate mathematical expressions."""
    try:
        # First try direct integer conversion
        return int(expr)
    except ValueError:
        try:
            # If that fails, evaluate as a mathematical expression
            # Replace any whitespace to prevent code injection
            clean_expr = expr.replace(' ', '')
            if all(c in '0123456789*+-/' for c in clean_expr):
                return int(eval(clean_expr))
            else:
                raise ValueError(f"Invalid characters in expression: {expr}")
        except Exception as e:
            raise ValueError(f"Invalid expression: {expr}")

def csv_to_dict(csv_path: Path) -> OrderedDict:
    """
    Convert CSV file to OrderedDict containing curriculum details.
    CSV should have headers: task,total_subtasks,estimated_minutes_per_subtask,progress
    """
    curriculum = OrderedDict()
    
    with open(csv_path) as f:
        # Skip header
        next(f)
        for line in f:
            # Split on comma, but preserve commas inside quoted strings
            parts = []
            current = ''
            in_quotes = False
            
            for char in line:
                if char == '"':
                    in_quotes = not in_quotes
                elif char == ',' and not in_quotes:
                    parts.append(current.strip())
                    current = ''
                else:
                    current += char
            parts.append(current.strip())  # Add the last part
            
            # Unpack the parts
            task, total_subtasks, estimated_minutes, progress = parts
            
            curriculum[task] = {
                'total_subtasks': safe_eval(total_subtasks),
                'estimated_minutes_per_subtask': safe_eval(estimated_minutes),
                'progress': ast.literal_eval(progress.strip('"'))
            }
    
    return curriculum

def generate_analysis(curriculum: OrderedDict) -> pd.DataFrame:
    """
    Analyze curriculum progress and generate DataFrame with completion estimates.
    """
    df_rows = []
    
    for task, details in curriculum.items():
        # Calculate remaining time
        completed_subtasks = len(details['progress'])
        remaining_subtasks = details['total_subtasks'] - completed_subtasks
        
        if remaining_subtasks < 0:
            raise ValueError(f"Task '{task}' has more progress entries than total subtasks")

        def avg_last_n(arr, n):
            if not arr:
                return details['estimated_minutes_per_subtask']
            return int(np.ceil(sum(arr[-n:]) / len(arr[-n:])))

        completed_mins = sum(details['progress'])
        remaining_mins_estimated = remaining_subtasks * details['estimated_minutes_per_subtask']

        remaining_mins_last_completed = remaining_mins_estimated
        remaining_mins_avg_last_n = remaining_mins_estimated
        if completed_subtasks > 0:
            remaining_mins_last_completed = remaining_subtasks * details['progress'][-1]
            remaining_mins_avg_last_n = remaining_subtasks * avg_last_n(details['progress'], min(5, completed_subtasks))
        
        df_rows.append({
            "task": task,
            "subtasks_completed": completed_subtasks,
            "subtasks_remaining": remaining_subtasks,
            "completed_mins": completed_mins,
            "remaining_mins_estimated": remaining_mins_estimated,
            "remaining_mins_last_completed": remaining_mins_last_completed,
            "remaining_mins_avg_last_n": remaining_mins_avg_last_n,                
        })
        
    return pd.DataFrame(df_rows)

def calculate_deadlines(df: pd.DataFrame, focus_hours_day: float, focus_hours_week: float) -> pd.DataFrame:
    """
    Calculate completion deadlines based on different estimation methods.
    """
    remaining_cols = [col for col in df.columns if col.startswith("remaining_")]
    
    for remaining_col in remaining_cols:
        df['total_' + remaining_col[len("remaining_"):]] = df["completed_mins"] + df[remaining_col]
    
    cumulative_sum_df = df.cumsum()
    cumulative_sum_df['task'] = df['task']
    
    def mins_to_focus_days(mins): 
        return np.ceil(mins / 60.0 / focus_hours_day)
    
    def mins_to_focus_week_days(mins): 
        return np.ceil((mins / 60.0 / focus_hours_week) * 7.0)

    today = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
    
    deadlines_rows = []
    for row in cumulative_sum_df.itertuples():
        deadlines_rows.append({
            "Task": row.task,
            "Estimated Deadline (by week)": today + timedelta(days=mins_to_focus_week_days(row.remaining_mins_estimated)),
            "Last Completed Deadline (by week)": today + timedelta(days=mins_to_focus_week_days(row.remaining_mins_last_completed)),
            "Avg Last N Deadline (by week)": today + timedelta(days=mins_to_focus_week_days(row.remaining_mins_avg_last_n)),
            "Estimated Deadline (by day)": today + timedelta(days=mins_to_focus_days(row.remaining_mins_estimated)),
            "Last Completed Deadline (by day)": today + timedelta(days=mins_to_focus_days(row.remaining_mins_last_completed)),
            "Avg Last N Deadline (by day)": today + timedelta(days=mins_to_focus_days(row.remaining_mins_avg_last_n)),
        })
    
    return pd.DataFrame(deadlines_rows)

def display_deadline_views(deadlines_df: pd.DataFrame):
    """
    Display deadlines in a 2x3 grid format:
    - First row: all 'by week' views side by side
    - Second row: all 'by day' views side by side
    """
    # Set pandas display options for cleaner output
    pd.set_option('display.max_rows', 50)
    pd.set_option('display.max_columns', None)
    pd.set_option('display.width', 1000)
    
    # Create the separate views
    views = {
        'by_week': [
            ("Estimated (by week)", deadlines_df[["Task", "Estimated Deadline (by week)"]]),
            ("Last Completed (by week)", deadlines_df[["Task", "Last Completed Deadline (by week)"]]),
            ("Avg Last N (by week)", deadlines_df[["Task", "Avg Last N Deadline (by week)"]])
        ],
        'by_day': [
            ("Estimated (by day)", deadlines_df[["Task", "Estimated Deadline (by day)"]]),
            ("Last Completed (by day)", deadlines_df[["Task", "Last Completed Deadline (by day)"]]),
            ("Avg Last N (by day)", deadlines_df[["Task", "Avg Last N Deadline (by day)"]])
        ]
    }
    
    # Helper function to format a single dataframe
    def format_df(df, title):
        df.columns = ['Task', 'Deadline']
        df_str = df.to_string(index=False)
        width = max(len(line) for line in df_str.split('\n'))
        title_padding = (width - len(title)) // 2
        formatted = f"{' ' * title_padding}{title}\n{'=' * width}\n{df_str}"
        return formatted.split('\n')
    
    # Process each row (by_week and by_day)
    for view_type, view_list in views.items():
        # Format all DataFrames in the current row
        formatted_dfs = [format_df(df, title) for title, df in view_list]
        
        # Find the maximum height among all formatted DataFrames
        max_height = max(len(df_lines) for df_lines in formatted_dfs)
        
        # Pad shorter DataFrames with empty lines to match the maximum height
        padded_dfs = [
            df_lines + [''] * (max_height - len(df_lines))
            for df_lines in formatted_dfs
        ]
        
        # Print the DataFrames side by side
        for row_idx in range(max_height):
            row_parts = []
            for df_lines in padded_dfs:
                row_parts.append(df_lines[row_idx].ljust(40))
            print('    '.join(row_parts))
        
        # Add a blank line between rows
        print('\n')

def main():
    args = parse_args()
    
    # Set pandas display options
    pd.set_option('display.max_rows', 50)
    pd.set_option('display.max_columns', None)
    pd.set_option('display.width', 1000)
    
    # Process curriculum data
    curriculum = csv_to_dict(args.csv_file)
    analysis_df = generate_analysis(curriculum)
    deadlines_df = calculate_deadlines(analysis_df, args.focus_hours_day, args.focus_hours_week)
    
    # Display results using the new function
    display_deadline_views(deadlines_df)

if __name__ == "__main__":
    main()
