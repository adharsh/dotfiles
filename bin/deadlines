#!/home/adharsh/miniforge3/envs/basic/bin/python

import argparse
from pathlib import Path
from datetime import datetime, timedelta
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request
from googleapiclient.discovery import build
import pickle
import pandas as pd

# Constants
SCOPES = ['https://www.googleapis.com/auth/calendar']
CONFIG_DIR = Path.home() / 'dotfiles' / 'credentials' / 'google_calendar'
CREDENTIALS_PATH = CONFIG_DIR / 'credentials.json'
TOKEN_PATH = CONFIG_DIR / 'token.pickle'

# Number of hours availabe for each day of the week
# Total: 50 hours
HOURS_PER_DAY = {
    "Monday": 7,
    "Tuesday": 9,
    "Wednesday": 9,
    "Thursday": 4,
    "Friday": 4,
    "Saturday": 6,
    "Sunday": 11
}

def get_credentials():
    """Get valid credentials, either from token file or by authenticating."""
    creds = None
    
    # Ensure config directory exists
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    
    # Try to load existing token
    if TOKEN_PATH.exists():
        with open(TOKEN_PATH, 'rb') as token:
            creds = pickle.load(token)
    
    # If no valid credentials available, authenticate
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file(
                str(CREDENTIALS_PATH),
                SCOPES
            )
            creds = flow.run_local_server(port=0)
        
        # Save the credentials for future runs
        with open(TOKEN_PATH, 'wb') as token:
            pickle.dump(creds, token)
    
    return creds

def create_calendar_event(event_date, title, description, calendar_name):
    """
    Create an all-day event in Google Calendar
    
    Args:
        event_date (str): Date in 'YYYY-MM-DD' format
        title (str): Event title
        description (str): Event description
        calendar_name (str): Name of the calendar to add event to
    """
    # Get credentials
    creds = get_credentials()
    
    # Build the service
    service = build('calendar', 'v3', credentials=creds)
    
    # Get calendar ID by name
    calendar_list = service.calendarList().list().execute()
    calendar_id = None
    
    for calendar in calendar_list['items']:
        if calendar['summary'] == calendar_name:
            calendar_id = calendar['id']
            break
    
    if not calendar_id:
        raise ValueError(f"Calendar '{calendar_name}' not found")
    
    # Create event
    event = {
        'summary': title,
        'description': description,
        'start': {
            'date': event_date,  # Format: YYYY-MM-DD
            'timeZone': 'UTC',
        },
        'end': {
            'date': event_date,
            'timeZone': 'UTC',
        }
    }
    
    event = service.events().insert(calendarId=calendar_id, body=event).execute()
    # print(f"Event created: {event.get('htmlLink')}")

def delete_all_events(calendar_name):
    """
    Delete all events from a specified calendar
    
    Args:
        calendar_name (str): Name of the calendar to delete events from
    """
    # Get credentials
    creds = get_credentials()
    
    # Build the service
    service = build('calendar', 'v3', credentials=creds)
    
    # Get calendar ID by name
    calendar_list = service.calendarList().list().execute()
    calendar_id = None
    
    for calendar in calendar_list['items']:
        if calendar['summary'] == calendar_name:
            calendar_id = calendar['id']
            break
    
    if not calendar_id:
        raise ValueError(f"Calendar '{calendar_name}' not found")
    
    # Get all events
    events_result = service.events().list(
        calendarId=calendar_id,
        maxResults=2500  # Adjust this number based on your needs
    ).execute()
    
    events = events_result.get('items', [])
    
    # Delete each event
    for event in events:
        service.events().delete(
            calendarId=calendar_id,
            eventId=event['id']
        ).execute()
        # print(f"Deleted event: {event.get('summary')}")
    
    # print(f"Deleted all events from calendar: {calendar_name}")


def load_csv_data(file_path):
    """
    Load CSV file, evaluate mathematical expressions, and handle empty actual_hrs entries.
    
    Args:
        file_path (str or Path): Path to the CSV file
        
    Returns:
        pandas.DataFrame: Processed DataFrame with evaluated expressions and empty actual_hrs as NaN
    """
    # Convert string path to Path object if needed
    path = Path(file_path) if isinstance(file_path, str) else file_path
    
    # Read CSV file
    df = pd.read_csv(path, skipinitialspace=True, comment='#')
    
    # Function to safely evaluate mathematical expressions
    def safe_eval(x):
        try:
            if pd.isna(x) or x == '':
                return pd.NA
            return eval(str(x))
        except Exception:
            return x
    
    # Evaluate expressions in estimated_hrs and actual_hrs columns
    df['estimated_hrs'] = df['estimated_hrs'].apply(safe_eval)
    df['actual_hrs'] = df['actual_hrs'].apply(safe_eval)

    return df

def format_days(total_days):
    """
    Format a duration in days to a string showing months, weeks, and days.
    
    Args:
        total_days (int): Total number of days
        
    Returns:
        str: Formatted string like "1 month, 2 weeks, 3 days" or "5 days"
    """
    # Calculate months (assuming 30 days per month)
    months = total_days // 30
    remaining_days = total_days % 30
    
    # Calculate weeks from remaining days
    weeks = remaining_days // 7
    days = remaining_days % 7
    
    # Build the output string
    parts = []
    
    if months > 0:
        parts.append(f"{months}m")
    
    if weeks > 0:
        parts.append(f"{weeks}w")
    
    if days > 0:
        parts.append(f"{days}d")
    
    # Handle special case when duration is 0
    if not parts:
        return "0d"
    
    return " ".join(parts)

def format_hours(total_hours):
    """
    Format a duration in hours to a string showing months, weeks, days, and hours.
    
    Args:
        total_hours (int): Total number of hours
        
    Returns:
        str: Formatted string like "1m 2w 3d 4h" or "5h"
    """
    # Calculate days from hours
    total_days = total_hours // 24
    hours = total_hours % 24
    
    # Calculate months (assuming 30 days per month)
    months = total_days // 30
    remaining_days = total_days % 30
    
    # Calculate weeks from remaining days
    weeks = remaining_days // 7
    days = remaining_days % 7
    
    # Build the output string
    parts = []
    
    if months > 0:
        parts.append(f"{months}m")
    
    if weeks > 0:
        parts.append(f"{weeks}w")
    
    if days > 0:
        parts.append(f"{days}d")
        
    if hours > 0:
        parts.append(f"{hours}h")
    
    # Handle special case when duration is 0
    if not parts:
        return "0h"
    
    return " ".join(parts)


def schedule_tasks(filepath, calendar_name="Focus", start_tomorrow=True, no_sync=False):
    """
    Schedule tasks from CSV file into calendar based on available hours per day.
    
    Args:
        filepath (str): Path to the CSV file containing tasks
        start_tomorrow (bool): If True, start scheduling from tomorrow; if False, start from today
    """
    # Load and process CSV
    df = load_csv_data(filepath)
    
    # Get start date
    start_date = datetime.now() + timedelta(days=1 if start_tomorrow else 0)
    current_date = start_date

    # Calculate padding lengths
    max_project_len = max(len(str(p)) for p in df['project']) + 5  # Add some buffer
    max_task_len = max(len(str(t)) for t in df['task']) + 5  # Add some buffer
    
    # Initialize hours remaining for the current day
    current_day = current_date.strftime("%A")
    hours_remaining = HOURS_PER_DAY[current_day]
    
    # Process each task
    events = []
    for _, row in df.iterrows():

        # Skip tasks that are already completed
        if row['actual_hrs'] is not pd.NA:
            continue

        task_hours = row['estimated_hrs']
        
        # While we still have hours to allocate for this task
        while task_hours > 0:
            # If we can fit the task in today's remaining time
            if task_hours <= hours_remaining:
                # Create calendar event
                events.append({
                    "date": current_date,
                    "project": row['project'],
                    "task": row['task'],
                    # "description": row['description'],
                    "estimated_hrs": row['estimated_hrs'],
                })
                hours_remaining -= task_hours
                task_hours = 0
            else:
                # Use up the remaining hours for today
                task_hours -= hours_remaining

                # Move to next day
                current_date += timedelta(days=1)
                current_day = current_date.strftime("%A")
                hours_remaining = HOURS_PER_DAY[current_day]

    # Calculate max duration length from all events
    max_duration_len = max(len(format_hours(event['estimated_hrs'])) for event in events) + 5  # Add some buffer

    # Print project and task timeline
    start_date = start_date
    last_project = events[0]['project']
    first_task_deadline = events[0]['date']
    last_task_deadline = None
    current_project_output = "" 

    print(f"Timeline from {(start_date + timedelta(days=1)).strftime('%Y-%m-%d')}.")
    for event in events:
        current_deadline = event['date']
        project = event['project']
        task = event['task']
        
        # Processing new project
        if project != last_project:
            time_diff = (last_task_deadline - first_task_deadline).days + 1
            duration_str = format_days(time_diff)
            print(f"\n{last_project:<{max_project_len}} {duration_str:<4} {last_task_deadline.strftime('%Y-%m-%d')}")
            print(current_project_output.rstrip())
            current_project_output = ""

            last_project = project
            first_task_deadline = current_deadline
            last_task_deadline = None
        
        duration_str = format_hours(event['estimated_hrs'])
        hours_given_day = str(HOURS_PER_DAY[event['date'].strftime('%A')]) + "h"
        current_project_output += f"  {task:<{max_task_len}} {duration_str:<{max_duration_len}} {event['date'].strftime('%a')} {hours_given_day:<6} {event['date'].strftime('%Y-%m-%d')}\n"
        last_task_deadline = current_deadline
    
    # Print the last project
    if last_project:
        time_diff = (last_task_deadline - first_task_deadline).days + 1
        duration_str = format_days(time_diff)
        print(f"\n{last_project:<{max_project_len}} {duration_str:<4} {last_task_deadline.strftime('%Y-%m-%d')}")
        print(current_project_output.rstrip())

    print()

    if no_sync:
        return

    # Create calendar events
    delete_all_events(calendar_name)
    for event in events:
        event_date = event['date'].strftime("%Y-%m-%d")
        title = f"{event['project']}: {event['task']}"
        description = (
            # f"{event['task']}:\n{event['description']}\n"
            f"{event['task']}"
            f"Estimated time: {event['estimated_hrs']} hours"
        )
        create_calendar_event(
            event_date=event_date,
            title=title,
            description=description,
            calendar_name=calendar_name
        )

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Schedule tasks from CSV into calendar')
    parser.add_argument('filepath', type=str, help='Path to the todos.csv file')
    parser.add_argument('--start-today', action='store_false', default=True, help='Start scheduling from today instead of tomorrow (default: start tomorrow)')
    parser.add_argument('--no-sync', action='store_true', default=False, help='Print schedule without updating Google Calendar')
  
    args = parser.parse_args()
    
    # Convert string path to Path object and verify it exists
    filepath = Path(args.filepath)
    if not filepath.exists():
        raise FileNotFoundError(f"Could not find file: {filepath}")
    
    schedule_tasks(filepath, start_tomorrow=args.start_today, no_sync=args.no_sync)
