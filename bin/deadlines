#!/home/adharsh/miniforge3/envs/basic/bin/python

import argparse
from pathlib import Path
from datetime import datetime, timedelta
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request
from googleapiclient.discovery import build
import pickle
import pandas as pd

# Constants
SCOPES = ['https://www.googleapis.com/auth/calendar']
CONFIG_DIR = Path.home() / 'dotfiles' / 'credentials' / 'google_calendar'
CREDENTIALS_PATH = CONFIG_DIR / 'credentials.json'
TOKEN_PATH = CONFIG_DIR / 'token.pickle'

# Number of minutes availabe for each day of the week
MINUTES_PER_DAY = {
    "Monday": 7*60,
    "Tuesday": 9*60,
    "Wednesday": 9*60,
    "Thursday": 4*60,
    "Friday": 4*60,
    "Saturday": 6*60,
    "Sunday": 11*60
}

def get_credentials():
    """Get valid credentials, either from token file or by authenticating."""
    creds = None
    
    # Ensure config directory exists
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    
    # Try to load existing token
    if TOKEN_PATH.exists():
        with open(TOKEN_PATH, 'rb') as token:
            creds = pickle.load(token)
    
    # If no valid credentials available, authenticate
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file(
                str(CREDENTIALS_PATH),
                SCOPES
            )
            creds = flow.run_local_server(port=0)
        
        # Save the credentials for future runs
        with open(TOKEN_PATH, 'wb') as token:
            pickle.dump(creds, token)
    
    return creds

def create_calendar_event(event_date, title, description, calendar_name):
    """
    Create an all-day event in Google Calendar
    
    Args:
        event_date (str): Date in 'YYYY-MM-DD' format
        title (str): Event title
        description (str): Event description
        calendar_name (str): Name of the calendar to add event to
    """
    # Get credentials
    creds = get_credentials()
    
    # Build the service
    service = build('calendar', 'v3', credentials=creds)
    
    # Get calendar ID by name
    calendar_list = service.calendarList().list().execute()
    calendar_id = None
    
    for calendar in calendar_list['items']:
        if calendar['summary'] == calendar_name:
            calendar_id = calendar['id']
            break
    
    if not calendar_id:
        raise ValueError(f"Calendar '{calendar_name}' not found")
    
    # Create event
    event = {
        'summary': title,
        'description': description,
        'start': {
            'date': event_date,  # Format: YYYY-MM-DD
            'timeZone': 'UTC',
        },
        'end': {
            'date': event_date,
            'timeZone': 'UTC',
        }
    }
    
    event = service.events().insert(calendarId=calendar_id, body=event).execute()
    # print(f"Event created: {event.get('htmlLink')}")

def delete_all_events(calendar_name):
    """
    Delete all events from a specified calendar
    
    Args:
        calendar_name (str): Name of the calendar to delete events from
    """
    # Get credentials
    creds = get_credentials()
    
    # Build the service
    service = build('calendar', 'v3', credentials=creds)
    
    # Get calendar ID by name
    calendar_list = service.calendarList().list().execute()
    calendar_id = None
    
    for calendar in calendar_list['items']:
        if calendar['summary'] == calendar_name:
            calendar_id = calendar['id']
            break
    
    if not calendar_id:
        raise ValueError(f"Calendar '{calendar_name}' not found")
    
    # Get all events
    events_result = service.events().list(
        calendarId=calendar_id,
        maxResults=2500  # Adjust this number based on your needs
    ).execute()
    
    events = events_result.get('items', [])
    
    # Delete each event
    for event in events:
        service.events().delete(
            calendarId=calendar_id,
            eventId=event['id']
        ).execute()
        # print(f"Deleted event: {event.get('summary')}")
    
    # print(f"Deleted all events from calendar: {calendar_name}")


def load_csv_data(file_path):
    """
    Load CSV file, evaluate mathematical expressions, and handle empty actual_mins entries.
    
    Args:
        file_path (str or Path): Path to the CSV file
        
    Returns:
        pandas.DataFrame: Processed DataFrame with evaluated expressions and empty actual_mins as NaN
    """
    # Convert string path to Path object if needed
    path = Path(file_path) if isinstance(file_path, str) else file_path
    
    # Read CSV file
    df = pd.read_csv(path, skipinitialspace=True, comment='#')
    
    # Function to safely evaluate mathematical expressions
    def safe_eval(x):
        try:
            if pd.isna(x) or x == '':
                return pd.NA
            return eval(str(x))
        except Exception:
            return x
    
    # Evaluate expressions in estimated_mins and actual_mins columns
    df['estimated_mins'] = df['estimated_mins'].apply(safe_eval)
    df['actual_mins'] = df['actual_mins'].apply(safe_eval)

    return df

def format_duration(total_days):
    """
    Format a duration in days to a string showing months, weeks, and days.
    
    Args:
        total_days (int): Total number of days
        
    Returns:
        str: Formatted string like "1 month, 2 weeks, 3 days" or "5 days"
    """
    # Calculate months (assuming 30 days per month)
    months = total_days // 30
    remaining_days = total_days % 30
    
    # Calculate weeks from remaining days
    weeks = remaining_days // 7
    days = remaining_days % 7
    
    # Build the output string
    parts = []
    
    if months > 0:
        parts.append(f"{months}m")
    
    if weeks > 0:
        parts.append(f"{weeks}w")
    
    if days > 0:
        parts.append(f"{days}d")
    
    # Handle special case when duration is 0
    if not parts:
        return "0d"
    
    return " ".join(parts)

def schedule_tasks(filepath, calendar_name="Focus", start_tomorrow=True, update_gcal=True):
    """
    Schedule tasks from CSV file into calendar based on available minutes per day.
    
    Args:
        filepath (str): Path to the CSV file containing tasks
        start_tomorrow (bool): If True, start scheduling from tomorrow; if False, start from today
    """
    # Load and process CSV
    df = load_csv_data(filepath)
    
    # Get start date
    start_date = datetime.now() + timedelta(days=1 if start_tomorrow else 0)
    current_date = start_date
    
    # Initialize minutes remaining for the current day
    current_day = current_date.strftime("%A")
    minutes_remaining = MINUTES_PER_DAY[current_day]
    
    # Process each task
    events = []
    for _, row in df.iterrows():

        # Skip tasks that are already completed
        if row['actual_mins'] is not pd.NA:
            continue

        task_minutes = row['estimated_mins']
        
        # While we still have minutes to allocate for this task
        while task_minutes > 0:
            # If we can fit the task in today's remaining time
            if task_minutes <= minutes_remaining:
                # Create calendar event
                events.append({
                    "date_str": current_date.strftime("%Y-%m-%d"),
                    "title_str": f"{row['project']}: {row['task']}",
                    "description_str": f"{row['task']}\nEstimated time: {row['estimated_mins']} minutes",

                    "date": current_date,
                    "project": row['project'],
                    "task": row['task'],
                })
                minutes_remaining -= task_minutes
                task_minutes = 0
            else:
                # Use up the remaining minutes for today
                task_minutes -= minutes_remaining

                # Move to next day
                current_date += timedelta(days=1)
                current_day = current_date.strftime("%A")
                minutes_remaining = MINUTES_PER_DAY[current_day]

    # Calculate maximum lengths for padding
    max_project_len = max(len(event['project']) for event in events)
    max_task_len = max(len(event['task']) for event in events)
    max_duration_len = max(len(format_duration((event['date'] - start_date).days)) for event in events)

    # Print project and task timeline
    start_date = start_date - timedelta(days=1)  # Subtract 1 day to include today
    last_project = events[0]['project']
    last_project_deadline = start_date 
    last_task_deadline = start_date
    current_project_output = "" 

    print(f"Timeline from {(start_date + timedelta(days=1)).strftime('%Y-%m-%d')}.")
    for event in events:
        current_deadline = event['date']
        project = event['project']
        task = event['task']
        
        if project != last_project:
            if last_project is not None:
                time_diff = (current_deadline - last_project_deadline).days
                duration_str = format_duration(time_diff)
                print(f"\n{last_project}: {'':{max_project_len-len(last_project)}} {duration_str:>{max_duration_len}}, {last_task_deadline.strftime('%Y-%m-%d')}")
                print(current_project_output.rstrip())
                current_project_output = ""
            last_project = project
            last_project_deadline = current_deadline
            last_task_deadline = None
        
        time_diff = (current_deadline - last_task_deadline).days if last_task_deadline else 0
        duration_str = format_duration(time_diff)
        current_project_output += f"  {task}: {'':{max_task_len-len(task)}} {duration_str:>{max_duration_len}}, {event['date_str']}\n"
        last_task_deadline = current_deadline
    
    # Print the last project
    if last_project:
        time_diff = (current_deadline - start_date).days  # Compare with start date
        duration_str = format_duration(time_diff)
        print(f"\n{last_project}: {'':{max_project_len-len(last_project)}} {duration_str:>{max_duration_len}}, {last_task_deadline.strftime('%Y-%m-%d')}")
        print(current_project_output.rstrip())

    print()

    # Create calendar events
    if update_gcal:
        delete_all_events(calendar_name)
        for event in events:
            create_calendar_event(
                event_date=event['date_str'],
                title=event['title_str'],
                description=event['description_str'],
                calendar_name=calendar_name
            )

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Schedule tasks from CSV into calendar')
    parser.add_argument('filepath', type=str, help='Path to the todos.csv file')
    parser.add_argument('--start-today', action='store_false', default=True, help='Start scheduling from today instead of tomorrow (default: start tomorrow)')
    parser.add_argument('--update-gcal', action='store_true', default=True, help='Update Google Calendar with the scheduled tasks')
  
    args = parser.parse_args()
    
    # Convert string path to Path object and verify it exists
    filepath = Path(args.filepath)
    if not filepath.exists():
        raise FileNotFoundError(f"Could not find file: {filepath}")
    
    schedule_tasks(filepath, start_tomorrow=args.start_today, update_gcal=args.update_gcal)
