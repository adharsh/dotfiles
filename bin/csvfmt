#!/usr/bin/env python3

import argparse
import csv
from typing import List
import sys
import tempfile
import shutil
import os

def format_field(value: str) -> str:
    """
    Prepare the CSV field for display, quoting and escaping as needed.
    """
    needs_quotes = False
    if '"' in value:
        value = value.replace('"', '""')
        needs_quotes = True

    if not needs_quotes:
        needs_quotes = any(ch in value for ch in {',', '\n'})

    if not needs_quotes:
        needs_quotes = value.startswith(' ') or value.endswith(' ')

    return f'"{value}"' if needs_quotes else value

def read_csv_rows(file_path: str) -> List[List[str]]:
    """
    Parse the CSV file while respecting quoted fields.
    """
    try:
        with open(file_path, newline='') as file:
            reader = csv.reader(file, skipinitialspace=True)
            return [row for row in reader]
    except FileNotFoundError:
        print(f"Error: File '{file_path}' not found.", file=sys.stderr)
        sys.exit(1)
    except csv.Error as e:
        print(f"Error parsing CSV in '{file_path}': {e}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error reading file '{file_path}': {str(e)}", file=sys.stderr)
        sys.exit(1)

def get_column_widths(rows: List[List[str]]) -> List[int]:
    """
    Determine the maximum display width for each column.
    """
    max_widths: List[int] = []
    for row in rows:
        if not row:
            continue

        if len(max_widths) < len(row):
            max_widths.extend([0] * (len(row) - len(max_widths)))

        for index, value in enumerate(row):
            formatted = format_field(value)
            max_widths[index] = max(max_widths[index], len(formatted))

    return max_widths

def format_csv(input_file: str, output_file: str | None = None, preview: bool = False) -> None:
    """
    Format the file with proper alignment, preserving original commas.
    """
    rows = read_csv_rows(input_file)
    max_widths = get_column_widths(rows)

    # Prepare formatted content
    formatted_rows = []
    for row in rows:
        if not row:
            formatted_rows.append('')
            continue

        formatted_parts = []

        for i, value in enumerate(row):
            formatted_value = format_field(value)
            column_width = max_widths[i] if i < len(max_widths) else len(formatted_value)
            padding = max(column_width - len(formatted_value), 0)

            if i < len(row) - 1:
                formatted_parts.append(f"{formatted_value}," + " " * (padding + 1))
            else:
                formatted_parts.append(formatted_value)

        formatted_rows.append("".join(formatted_parts))

    formatted_content = "\n".join(formatted_rows)

    if preview:
        print(formatted_content)
        return

    output_path = output_file if output_file is not None else input_file

    # Create a temporary file
    fd, temp_path = tempfile.mkstemp(text=True)
    try:
        with os.fdopen(fd, 'w') as temp_file:
            temp_file.write(formatted_content)
        # Replace the target file with the temporary file
        shutil.move(temp_path, output_path)
        if output_file is not None:
            print(f"Formatted CSV has been written to '{output_file}'")
    except Exception as e:
        print(f"Error writing to file: {str(e)}", file=sys.stderr)
        # Clean up the temporary file if it still exists
        if os.path.exists(temp_path):
            os.unlink(temp_path)
        sys.exit(1)

def main() -> None:
    parser = argparse.ArgumentParser(
        description="Format CSV files with dynamic column alignment"
    )
    parser.add_argument(
        "input_files",
        nargs="+",
        help="Input CSV file(s) to format"
    )
    parser.add_argument(
        "-o", "--output",
        help="Output file (optional, defaults to overwriting input file)",
        default=None
    )
    parser.add_argument(
        "-p", "--preview",
        help="Preview the formatted output without writing to file",
        action="store_true"
    )
    
    args = parser.parse_args()
    if len(args.input_files) > 1 and args.output:
        parser.error("--output cannot be used when formatting multiple files")

    for input_file in args.input_files:
        format_csv(
            input_file,
            args.output if args.output and len(args.input_files) == 1 else None,
            args.preview,
        )

if __name__ == "__main__":
    main()
